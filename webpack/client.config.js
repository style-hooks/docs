const {createDevelopment, createProduction} = require('@stellar-apps/webpack')
const webpack = require('webpack')
const {StatsWriterPlugin} = require('webpack-stats-plugin')
const PWAManifestPlugin = require('webpack-pwa-manifest')
const CircularDependencyPlugin = require('circular-dependency-plugin')
const OfflinePlugin = require('offline-plugin')
const md5File = require('md5-file')
const path = require('path')
const defaults = require('./default.config')
const paths = require('./paths')


const isDev = process.env.NODE_ENV === 'development' || !process.env.NODE_ENV
const stage = process.env.STAGE || 'development'
const createConfig = isDev ? createDevelopment : createProduction
const analyzeBundle = process.env.ANALYZE === 'true'
let envConfig

if (isDev) {
  // Development mode config
  envConfig = {
    devtool: 'eval',
    output: {
      globalObject: 'this',
      filename: `js/[name].js`,
      chunkFilename: `js/[name].js`
    },
    node: {
      querystring: true,
    },
    plugins: [
      new CircularDependencyPlugin({exclude: /node_modules/, failOnError: true})
    ]
  }
}
else {
  // Production mode config
  const TerserPlugin = require('terser-webpack-plugin')
  const CompressionPlugin = require('compression-webpack-plugin')
  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
  const zlib = require('zlib')

  class BrotliRuntimeChunkPlugin {
    // Define `apply` as its prototype method which is supplied with compiler as its argument
    apply(compiler) {
      // Specify the event hook to attach to
      compiler.hooks.emit.tapAsync(
        'BrotliRuntimeChunkPlugin',
        (compilation, callback) => {
          const webpackStatsJson = compilation.getStats().toJson()

          for (let chunk of webpackStatsJson.chunks.filter(c => c.entry)) {
            for (let filename of chunk.files) {
              // Get the asset source for each file generated by the chunk:
              const source = zlib.brotliCompressSync(
                compilation.assets[filename].source().replace('+".js"', '+".js.br"'),
                {[zlib.constants.BROTLI_PARAM_QUALITY]: 11}
              )

              compilation.assets[`${filename}.br`] = {
                ...compilation.assets[`${filename}.br`],
                source: () => source,
                size: () => source.length
              }
            }

          }

          callback()
        }
      )
    }
  }

  envConfig = {
    plugins: [
      // new OfflinePlugin({
      //   externals: ['/'],
      //   ServiceWorker: {
      //     minify: stage === 'production',
      //     output: 'sw.js',
      //     publicPath: '/sw.js'
      //   }
      // }),
      new webpack.LoaderOptionsPlugin({minimize: false, debug: false}),
      analyzeBundle ? new BundleAnalyzerPlugin() : () => {},
      analyzeBundle || stage !== 'development' ? () => {} : new BrotliRuntimeChunkPlugin(),
      analyzeBundle ? () => {} : new CompressionPlugin({
        filename: stage === 'development' ? '[path].br' : '[path]',
        algorithm: 'brotliCompress',
        test: /\.(js)(\?.*)?$/,
        compressionOptions: {level: 11},
        threshold: 0,
        deleteOriginalAssets: false
      }),
      new StatsWriterPlugin({fields: ['publicPath', 'chunks']})
    ],

    optimization: {
      minimize: true,
      minimizer: [
        new TerserPlugin({
          cache: true,
          parallel: 4,
          terserOptions: {
            compress: {
              passes: 2,
              keep_infinity: true,
              drop_console: false,
              pure_getters: 'strict',
              toplevel: true,
              unsafe_comps: true,
              unsafe_Function: true,
              unsafe_math: true,
              unsafe_proto: true,
              unsafe_undefined: true,
              warnings: false,
              ecma: 5,
              dead_code: true
            },
            output: {
              comments: false
            },
            sourceMap: false
          }
        })
      ],

      splitChunks: {
        chunks: 'async',
        cacheGroups: {
          commons: {
            chunks: 'all',
            minChunks: 2,
            reuseExistingChunk: true,
          },
          vendor: {
            test: /node_modules/,
            chunks: 'initial',
            name: 'vendor',
            priority: 10,
            enforce: true,
            reuseExistingChunk: true,
          },
          polyfill: {
            test: /node_modules\/(core-js|@babel\/runtime)/,
            chunks: 'all',
            name: 'polyfill',
            priority: 15,
            enforce: true,
            reuseExistingChunk: true
          }
        }
      },
    }
  }
}

const presets = [
  ['@stellar-apps/react-app', {
    es: {
      env: {
        targets: {
          browsers: '>3%'
        }
      },
      runtime: {
        absoluteRuntime: path.dirname(
          require.resolve('@babel/runtime-corejs3/package.json')
        )
      }
    }
  }]
]

module.exports = createConfig(
  defaults,
  {
    name: 'client',
    entry: [path.join(paths.src, 'client.js')],
    output: {
      path: path.join(paths.dist, stage, 'client'),
      filename: `js/[hash].js`,
      chunkFilename: `js/[contenthash].js`
    },
    babelOverride: {
      include: [paths.src, ...paths.inherits],
      internal: {presets},
      external: {presets}
    },
    plugins: [
      // Creates the PWA manifest
      new PWAManifestPlugin({
        // plugin options
        filename: 'style-hooks.json',
        // we aren't using html-webpack=plugin so this option is irrelevant
        inject: false,
        // we can't access easily a fingerprinted manifest in the app
        // and manifests aren't supposed to be cacheable anyway
        fingerprints: false,
        // actual content
        name: 'Style Hooks',
        short_name: 'Style Hooks',
        description: `Turn your React function components into responsive components with style props using Style Hooks and Emotion`,
        start_url: stage === 'development' ? '.' : `https://${process.env.DOMAIN}/`,
        display: "standalone",
        background_color: "#e23164",
        theme_color: "#e23164",
        orientation: "portrait-primary",
        icons: [
          {
            src: path.join(paths.src, 'public/images/manifest-512.png'),
            sizes: [192, 512],
            destination: path.join(
              'images',
              // this ensures we always get updated icons through to the user when they
              // are created
              md5File.sync(path.join(paths.src, 'public/images/manifest-512.png'))
            )
          }
        ]
      }),
      new webpack.DefinePlugin({
        __DEV__: JSON.stringify(isDev),
        __SERVER__: JSON.stringify(false),
        __CLIENT__: JSON.stringify(true),
        __STAGE__: JSON.stringify(stage)
      }),
    ]
  },
  envConfig
)